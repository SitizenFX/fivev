--- a/net/minecraft/core/MappedRegistry.java
+++ b/net/minecraft/core/MappedRegistry.java
@@ -30,6 +_,8 @@
 import net.minecraft.util.RandomSource;
 
 public class MappedRegistry<T> implements WritableRegistry<T> {
+    private static final org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger();
+    private static final org.apache.logging.log4j.Marker MARKER = net.minecraftforge.registries.ForgeRegistry.REGISTRIES;
     private final ResourceKey<? extends Registry<T>> key;
     private final ObjectList<Holder.Reference<T>> byId = new ObjectArrayList<>(256);
     private final Reference2IntMap<T> toId = Util.make(new Reference2IntOpenHashMap<>(), p_308420_ -> p_308420_.defaultReturnValue(-1));
@@ -85,6 +_,7 @@
 
     @Override
     public Holder.Reference<T> register(ResourceKey<T> p_256252_, T p_256591_, RegistrationInfo p_329661_) {
+        markKnown();
         this.validateWrite(p_256252_);
         Objects.requireNonNull(p_256252_);
         Objects.requireNonNull(p_256591_);
@@ -103,6 +_,8 @@
                 reference.bindKey(p_256252_);
             } else {
                 reference = this.byKey.computeIfAbsent(p_256252_, p_358082_ -> Holder.Reference.createStandAlone(this, (ResourceKey<T>)p_358082_));
+                // Forge: Bind the value immediately so it can be queried while the registry is not frozen
+                reference.bindValue(p_256591_);
             }
 
             this.byKey.put(p_256252_, reference);
@@ -274,7 +_,6 @@
             return this;
         } else {
             this.frozen = true;
-            this.byValue.forEach((p_247989_, p_247990_) -> p_247990_.bindValue((T)p_247989_));
             List<ResourceLocation> list = this.byKey
                 .entrySet()
                 .stream()
@@ -290,7 +_,8 @@
                         throw new IllegalStateException("Some intrusive holders were not registered: " + this.unregisteredIntrusiveHolders.values());
                     }
 
-                    this.unregisteredIntrusiveHolders = null;
+                    // Forge: We freeze/unfreeze vanilla registries more than once, so we need to keep the unregistered intrusive holders map around.
+                    //this.unregisteredIntrusiveHolders = null;
                 }
 
                 if (this.allTags.isBound()) {
@@ -304,8 +_,9 @@
                         .sorted()
                         .toList();
                     if (!list1.isEmpty()) {
-                        throw new IllegalStateException("Unbound tags in registry " + this.key() + ": " + list1);
-                    } else {
+                        LOGGER.debug(MARKER, "Unbound tags in registry " + this.key() + ": " + list1);
+                        bindAllUnboundTagsToEmpty();
+                    } /* else */ {
                         this.allTags = MappedRegistry.TagSet.fromMap(this.frozenTags);
                         this.refreshTagsInHolders();
                         return this;
@@ -315,6 +_,13 @@
         }
     }
 
+    private void bindAllUnboundTagsToEmpty() {
+        for (var tag : this.frozenTags.values()) {
+            if (!tag.isBound())
+                tag.bind(List.of());
+        }
+    }
+
     @Override
     public Holder.Reference<T> createIntrusiveHolder(T p_205915_) {
         if (this.unregisteredIntrusiveHolders == null) {
@@ -389,6 +_,31 @@
         };
     }
 
+    public boolean isIntrusive() {
+        return this.unregisteredIntrusiveHolders != null;
+    }
+
+    private static final Set<ResourceLocation> KNOWN = new java.util.LinkedHashSet<>();
+    public static Set<ResourceLocation> getKnownRegistries() {
+        return java.util.Collections.unmodifiableSet(KNOWN);
+    }
+
+    protected final void markKnown() {
+        // Some vanilla registries rely on others in some objects
+        // So we have to have a last-in ordering. Simplest way is to just remove and re-add our selves.
+        // A copy of this map is then captured after vanilla bootstraping to freeze it hopefully before Modder's change the order.
+        // https://github.com/MinecraftForge/MinecraftForge/issues/10179
+        KNOWN.remove(key().location());
+        KNOWN.add(key().location());
+    }
+
+    /** @deprecated Forge: For internal use only. Use the Register events when registering values. */
+    @Deprecated
+    public void unfreeze() {
+        this.frozen = false;
+        this.allTags = MappedRegistry.TagSet.unbound();
+    }
+
     @Override
     public Registry.PendingTags<T> prepareTagReload(TagLoader.LoadResult<T> p_368827_) {
         if (!this.frozen) {
@@ -436,6 +_,11 @@
                 @Override
                 public HolderLookup.RegistryLookup<T> lookup() {
                     return registrylookup;
+                }
+
+                @Override
+                public List<Holder<T>> getPending(TagKey<T> key) {
+                    return map.getOrDefault(key, List.of());
                 }
 
                 @Override
